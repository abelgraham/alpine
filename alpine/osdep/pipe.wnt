#line 2 "osdep/pipe.wnt"



/*======================================================================
    pipe
    
    Initiate I/O to and from a process.  These functions are similar to 
    popen and pclose, but both an incoming stream and an output file are 
    provided.
   
 ====*/


/*----------------------------------------------------------------------
     Pipe a single character

  This works a little bit differently from unix.  Here, we collect
  the characters into a temp file.  In close_system_pipe, the output
  can then be run, so execution doesn't take place until then.

  Piping is possible in win32 through the CreatePipe method, but we would
  likely need to do our own buffering, writing is purportedly slow 1 byte
  at a time, 

  Args: command -- string to hand the shell
	outfile -- address of pointer containing file to receive output
                   caller's responsibility to unlink
	errfile -- file to write stderr to
	           apparently unused, but could get this working
	mode -- mode for type of shell, signal protection etc...
  More mode bits for unix pine, but the following are the ones used
  for piping in PC-Pine...
    PIPE_WRITE tells us we need to open a pipe to write the child's
	stdin.
    PIPE_READ tells us we need to open a pipe to read from the child's
	stdout/stderr.  *NOTE*  Having neither of the above set means 
	we're not setting up any pipes, just forking the child and exec'ing
	the command.  Also, this takes precedence over any named outfile.
    PIPE_STDERR means we're to tie the childs stderr to the same place
	stdout is going.  *NOTE* This only makes sense then if PIPE_READ
	or an outfile is provided.  Also, this takes precedence over any
	named errfile.
    PIPE_RESET in unix means to run in terminal mode.  In PC-Pine, _RESET
        was a shortcut for just executing command.  We'll try to pay
	attention to the above flags to make sure we do the right thing.
    PIPE_RUNNOW was added for windows for the case pipe is called to run
        a shell program (like for url viewing).  This is the only option
	where we don't wait for child termination, and is only obeyed if
	PIPE_WRITE and PIPE_READ aren't set

  Returns: pointer to alloc'd PIPE_S on success, NULL otherwise
 ----*/
PIPE_S *
open_system_pipe(command, outfile, errfile, mode, timeout)
     char  *command;
     char **outfile;
     char **errfile;
     int    mode, timeout;
{
    PIPE_S *syspipe = NULL;
    int exit_code = 0;
    char cmdbuf[1024], *p;
    unsigned flags = 0;

    dprint(5, (debugfile, "Opening pipe: \"%s\" (%s%s%s%s%s%s)\n",
	       command ? command : "NULL cmd",
	       (mode & PIPE_WRITE)   ? "W":"", (mode & PIPE_READ)  ? "R":"",
	       (mode & PIPE_NOSHELL) ? "N":"", (mode & PIPE_PROT)  ? "P":"",
	       (mode & PIPE_USER)    ? "U":"", (mode & PIPE_RESET) ? "T":""));

    if(mode & PIPE_STDERR)
      flags |= MSWIN_EAW_CAPT_STDERR;
    /* 
     * It'll be a lot more difficult to support READing and WRITing.
     * This was never supported, and there don't look to be any cases
     * that set both of these flags anymore for win32.
     *
     * errfile could probably be supported pretty easily
     */

    if(errfile){
	q_status_message(SM_ORDER, 3, 3,
			  "Pipe arg not yet supported: Error File");
	return(NULL);
    }


    if((mode & PIPE_RUNNOW)
       && !(mode & (PIPE_WRITE | PIPE_READ | PIPE_STDERR))){
	if(mswin_shell_exec(command, NULL, NULL) == 0){
	    syspipe = (PIPE_S *) fs_get(sizeof(PIPE_S));
	    memset(syspipe, 0, sizeof(PIPE_S));
	    return(syspipe);
	}
	else
	  return(NULL);
    }

    strncpy(cmdbuf, command, sizeof(cmdbuf));
    cmdbuf[sizeof(cmdbuf)-1] = '\0';

    syspipe = (PIPE_S *) fs_get(sizeof(PIPE_S));
    memset(syspipe, 0, sizeof(PIPE_S));
    syspipe->mode = mode;
    if(!outfile){
	syspipe->deloutfile = 1;
	if(mode & PIPE_READ){
	    syspipe->outfile = temp_nam(NULL, "po");
	    unlink(syspipe->outfile);
	}
    }
    else{
	if(!*outfile) /* asked for, but not named? */
	  *outfile = temp_nam(NULL, "po");
	unlink(*outfile);
	syspipe->outfile = cpystr(*outfile);
    }

    if(mode & PIPE_WRITE){
	/*
	 * Create tmp file to write, spawn child in close_pipe
	 * after tmp file's written...
	 */
	syspipe->infile = temp_nam(NULL, "pw");
	syspipe->out.f = fopen(syspipe->infile, "wb");
	syspipe->command = cpystr(cmdbuf);
	dprint(1, (debugfile, "pipe write: %s", cmdbuf));
    }
    else if(mode & PIPE_READ){
	/* 
	 * Create a tmp file for command result, exec the command
	 * here into temp file, and return file pointer to it...
	 */
	syspipe->command = cpystr(cmdbuf);
	dprint(1, (debugfile, "pipe read: %s", cmdbuf));
	if(pipe_mswin_exec_wrapper("pipe command", cmdbuf,
				   NULL, syspipe->outfile,
				   &exit_code,
				   flags)){
	    if(syspipe->outfile)
	      fs_give((void **)&syspipe->outfile);

	    zot_pipe(&syspipe);
	}
	else{
	  syspipe->in.f = fopen(syspipe->outfile, "rb");
	  syspipe->exit_code = exit_code;
	}
    }
    else{
	/* we just run the command taking outfile into account */
	if(pipe_mswin_exec_wrapper("pipe command", cmdbuf,
			       NULL, syspipe->outfile,
			       &exit_code,
			       flags)){
	    if(syspipe->outfile)
	      fs_give((void **)&syspipe->outfile);

	    zot_pipe(&syspipe);
	}
	else
	  syspipe->exit_code = exit_code;
    }

    return(syspipe);
}



/*----------------------------------------------------------------------
    Close pipe previously allocated and wait for child's death

  Args: syspipe -- address of pointer to struct returned by open_system_pipe

  Two modes of return values for backcompat.
      If exitval == NULL
	 returns exit status of child or -1 if invalid syspipe
      If exitval != NULL
         returns -1 if invalid syspipe or 0 if ok. In that case, exitval
	 of child is returned in exitval
 ----*/
int
close_system_pipe(syspipe, exitval, dontnewmail)
    PIPE_S **syspipe;
    int     *exitval;
    int      dontnewmail;
{
    int rv = 0;
    unsigned flags = 0;

    if(!(syspipe && *syspipe))
      return(-1);

    if((*syspipe)->mode & PIPE_STDERR)
      flags |= MSWIN_EAW_CAPT_STDERR;

    if(((*syspipe)->mode & PIPE_WRITE) && (*syspipe)->out.f){
	fclose((*syspipe)->out.f);
	/*
	 * PIPE_WRITE can't start process till now,  all the others
	 *  will have already run
	 */
	if(pipe_mswin_exec_wrapper("pipe command", (*syspipe)->command,
				   (*syspipe)->infile, (*syspipe)->outfile,
				   &(*syspipe)->exit_code, flags))
	  /* some horrible error just occurred */
	  rv = -1;
    }
    else if((*syspipe)->mode & PIPE_READ)
      if((*syspipe)->in.f)
	fclose((*syspipe)->in.f);

    if(exitval){
	*exitval = (*syspipe)->exit_code;
	dprint(5, (debugfile, "Closed pipe: exitval=%d\n", *exitval));
    }

    if((*syspipe)->infile)
      unlink((*syspipe)->infile);

    if((*syspipe)->outfile && (*syspipe)->deloutfile)
      unlink((*syspipe)->outfile);

    if(rv != -1 && !exitval)
      rv = (*syspipe)->exit_code;

    zot_pipe(syspipe);

    if(!exitval){
	dprint(5, (debugfile, "Closed pipe: rv=%d\n", rv));
    }

    return(rv);
}

/*
 * Wrapper around mswin_exec_and_wait()
 */
int
pipe_mswin_exec_wrapper(whatsit, command, infile, outfile,
			exit_val, flags, pipecb_f)
    char    *whatsit;
    char    *command;
    char    *infile;
    char    *outfile;
    int     *exit_val;
    unsigned flags;
    void   (*pipecb_f)(PIPE_S *, int);
{
    bitmap_t bitmap;
    int rv;

    flags |= MSWIN_EAW_CTRL_C_CANCELS;

    q_status_message(SM_ORDER, 0, 0,
		     "Waiting for called program to finish...");

    flush_status_messages(1);
    setbitmap(bitmap);
    draw_keymenu(&pipe_cancel_keymenu, bitmap, ps_global->ttyo->screen_cols,
		 1-FOOTER_ROWS(ps_global), 0, FirstMenu);
    rv = mswin_exec_and_wait(whatsit, command, infile, outfile,
			     exit_val, flags);
    clearfooter(ps_global);
    ps_global->mangled_footer = 1;

    if(rv == -2)
      q_status_message1(SM_ORDER, 2, 3, "Ignoring completion of %s", command);
    return rv;
}
