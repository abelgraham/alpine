#line 2 "osdep/execview.wnt"
/*----------------------------------------------------------------------
    Routine to execute command mailcap says is used to display MIME segment
    under MS-Windows win32 interface

 The exported routine is:

    exec_mailcap_cmd -- 

 ----*/


/* ----------------------------------------------------------------------
   Execute the given 

  Args: cmd -- 
	image_file --
  
     
  ----*/

void
exec_mailcap_cmd(mc_cmd, image_file, needsterminal)
    MCAP_CMD_S *mc_cmd;
    char *image_file;
    int   needsterminal; /* not used in Windows */
{
    STARTUPINFO		start_info;
    PROCESS_INFORMATION	proc_info;
    DWORD		exit_code;
    WINHAND		childProcess;
    int			success = 0;
    char               *cmd;

    /* no special handling yet, but could be used to replace '*' hack */
    if(mc_cmd)
      cmd = mc_cmd->command;
    else
      return;

    dprint(9, (debugfile, "run_viewer: command=%s\n", cmd ? cmd : "?")) ;

    cancel_busy_alarm(1);

    /* Set to READONLY so the viewer can't try to edit it and keep it around */
    SetFileAttributes(image_file, FILE_ATTRIBUTE_READONLY);

    if(*cmd == '*' || (*cmd == '\"' && *(cmd+1) == '*')){
	/*
	 * It has been asked that there be the ability to do an 
	 * "Open With..." on attachments like you can from the
	 * Windows file browser.  After looking into this, it
	 * seems that the only way to do this would be through
	 * an undocumented hack.  Here, we would pass "openas" as
	 * the verb to mswin_shell_exec (also some changes in
	 * mswin_shell_exec).  Since this is the delicate world
	 * of attachment handling, it seems right not to rely on
	 * a hack.  The interface wouldn't be too clean anyways,
	 * as we would have to download the attachment only to
	 * display the "Open With..." dialog.  Go figure, some
	 * things Microsoft just wants to keep to themselves.
	 */
	success = mswin_shell_exec(cmd, NULL, &childProcess) == 0;
    }
    else{
	memset(&proc_info, 0, sizeof(proc_info));
	memset(&start_info, 0, sizeof(start_info));
	start_info.dwFlags	    = STARTF_FORCEONFEEDBACK;
	start_info.wShowWindow  = SW_SHOWNORMAL;

	if(CreateProcess(NULL, cmd, NULL, NULL, FALSE,
			 CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP,
			 NULL, NULL, &start_info, &proc_info) == TRUE){
	    q_status_message(SM_ORDER, 0, 4, "VIEWER command completed");
	    dprint (3, (debugfile, "CreatProcess(%s)  Success.\n",
		    cmd ? cmd : "?"));
	    childProcess = proc_info.hProcess;
	    success = 1;
	}
    }

    if(success){
	/* Arrange to have the file deleted when the viewer exits.  But
	 * if that fails, tell the user. */
	if(mswin_ontask_del(childProcess, image_file))
	  q_status_message1(SM_ORDER, 0, 4,
			 "Temp file %s created, but not deleted", image_file);
    }
    else{
	int rc = (int) GetLastError();
	SetFileAttributes(image_file, FILE_ATTRIBUTE_NORMAL);
	unlink(image_file);
	q_status_message2(SM_ORDER, 3, 4, "\007Can't start viewer. %s%s.",
			  (rc == 2 || rc == 3) ? "Viewer not found:  " :
			  (rc == 8) ? "Not enough memory" : "Windows error ",
			  (rc == 2 || rc == 3) ? cmd :
			  (rc == 8) ? "" : int2string(rc));
    }
}


/* ----------------------------------------------------------------------
   Execute the given test= cmd

  Args: cmd -- command to execute
  Returns exit status
  
  ----*/
int
exec_mailcap_test_cmd(cmd)
    char *cmd;
{
    return((WinExec(cmd, SW_SHOWMINNOACTIVE) < 32) ? 1 : 0);
}


char *
url_os_specified_browser(url)
    char *url;
{
    return(mswin_reg_default_browser(url));
}

/*
 * Return a pretty command, on some OS's we might do something
 * different than just display the command.
 *
 * free_ret - whether or not to free the return value
 */
char *
execview_pretty_command(mc_cmd, free_ret)
    MCAP_CMD_S *mc_cmd;
    int        *free_ret;
{
    int rv_to_free = 0;
    char *str = NULL, *cmd;

    if(!mc_cmd)
      return NULL;
    cmd = mc_cmd->command;
    if(*cmd == '*' || (*cmd == '\"' && *(cmd+1) == '*')){
	if(!strncmp(cmd + ((*cmd == '\"') ? 2 : 1), "DDE*", 4))
	    str = cpystr("via app already running");
	else if(!strncmp(cmd + ((*cmd == '\"') ? 2 : 1),"ShellEx*",8))
	    str = cpystr("via Explorer defined app");
	else
	  str = cpystr("via Windows-specific method");
	rv_to_free = 1;
    }
    else
      str = mc_cmd->command;
    if(free_ret)
      *free_ret = rv_to_free;
    return(str);
}
